{"version":3,"sources":["helpers/calculatePath.js","components/Graph.jsx","helpers/fordFulkerson.js","components/MintiForm.jsx","components/FulkersonForm.jsx","components/Tabs.jsx","App.js","reportWebVitals.js","index.js"],"names":["lowestCostNode","costs","processed","Object","keys","reduce","lowest","node","includes","calculatePath","graph","assign","finish","Infinity","start","parents","child","cost","children","n","newCost","push","optimalPath","parent","reverse","distance","path","GraphComponent","props","nodes","vertices","Array","from","map","id","label","title","edges","vertex","to","weight","toString","options","layout","hierarchical","color","height","Graph","this","adjMatrix","idList","Queue","queue","dequeue","length","shift","enqueue","item","getLength","isEmpty","getContents","BFS","G","src","destination","pred","dist","visited","Q","q","cur","undefined","current","getNeighbours","neighbours","i","getPath","dest","unshift","ResidualGraph","init","row","j","minCapacity","min","fromIndex","toIndex","value","adjustEdgesInPath","val","getIdIndex","console","log","prototype","addNode","newRow","deleteNode","index","found","splice","addEdge","id1","id2","index1","index2","found1","found2","updateEdge","newWeight","deleteEdge","print","calculateMaxFlow","startVertex","finishVertex","getNodeNames","forEach","sink","res","RS","S","cut","Set","flow","k","s","l","add","FordFulkerson","nodeStartNames","nodeFinishNames","useStyles","makeStyles","theme","formControl","minWidth","marginRight","filterVertices","filter","classes","emptyVertex","useState","setStartVertex","setFinishVertex","setVertices","setDistance","setPath","resetResult","addNewVertex","getVertexName","name","hasRequiredVertices","disableCalculationButton","formattedPath","style","display","alignItems","justifyContent","flexDirection","width","marginBottom","FormControl","className","InputLabel","htmlFor","Input","aria-describedby","onChange","event","target","disabled","newVertices","updateVertexStart","updateVertexFinish","updateVertexWeight","IconButton","size","onClick","fontSize","key","removeVertex","Button","variant","filteredVertices","result","finishName","calculatedPath","marginTop","join","maxFlow","setMaxFlow","minCut","setMinCut","TabPanel","other","role","hidden","aria-labelledby","Box","p","Typography","a11yProps","root","flexGrow","backgroundColor","palette","background","paper","SimpleTabs","React","setValue","AppBar","position","Tabs","newValue","aria-label","Tab","MintiForm","FulkersonForm","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.11f84b8d.chunk.js","sourcesContent":["const lowestCostNode = (costs, processed) => {\n    return Object.keys(costs).reduce((lowest, node) => {\n        if (lowest === null || costs[node] < costs[lowest]) {\n            if (!processed.includes(node)) {\n                lowest = node;\n            }\n        }\n        return lowest;\n    }, null);\n};\n\n// function that returns the minimum cost and path to reach Finish\nconst calculatePath = (graph) => {\n\n    // track lowest cost to reach each node\n    const costs = Object.assign({finish: Infinity}, graph.start);\n\n    // track paths\n    const parents = {finish: null};\n    for (let child in graph.start) {\n        parents[child] = 'start';\n    }\n\n    // track nodes that have already been processed\n    const processed = [];\n\n    let node = lowestCostNode(costs, processed);\n\n    while (node) {\n        let cost = costs[node];\n        let children = graph[node];\n        for (let n in children) {\n            let newCost = cost + children[n];\n            if (!costs[n]) {\n                costs[n] = newCost;\n                parents[n] = node;\n            }\n            if (costs[n] > newCost) {\n                costs[n] = newCost;\n                parents[n] = node;\n            }\n        }\n        processed.push(node);\n        node = lowestCostNode(costs, processed);\n    }\n\n    let optimalPath = ['finish'];\n    let parent = parents.finish;\n    while (parent) {\n        optimalPath.push(parent);\n        parent = parents[parent];\n    }\n    optimalPath.reverse();\n\n    const results = {\n        distance: costs.finish,\n        path: optimalPath\n    };\n\n    return results;\n};\n\nexport default calculatePath;","import React from \"react\";\nimport Graph from \"react-graph-vis\";\n\nconst GraphComponent = (props) => {\n    const { nodes, vertices } = props;\n\n    const getGraph = () => ({\n        nodes: Array.from(nodes).map(node => ({\n            id: node,\n            label: node,\n            title: node,\n        })),\n        edges: vertices.map(vertex => ({\n            from: vertex.start,\n            to: vertex.finish,\n            label: vertex.weight.toString()\n        }))\n    })\n\n    const options = {\n        layout: {\n            hierarchical: true\n        },\n        edges: {\n            color: \"#000000\"\n        },\n        height: \"500px\"\n    };\n\n    return (\n        <Graph\n            graph={getGraph()}\n            options={options}\n        />\n    );\n}\n\nexport default GraphComponent;","/*\n * A graph that contains nodes and vertice, stored as an adjacency matrix.\n * @constructor  \n */\nfunction Graph() {\n    this.adjMatrix = [];  // Once we add a node, this will also contain sub arrays. Edge weights are stored in [i][j], where i is the name of the 'from' node and j is the 'to' node\n    this.idList = [];  // The name associated with each node.\n}\n\nfunction Queue() {\n    var queue = [];\n\n    this.dequeue = function () {\n        if (queue.length === 0) {\n            return undefined;\n        } else {\n            return queue.shift();\n        }\n    };\n\n    this.enqueue = function (item) {\n        queue.push(item);\n    };\n\n    this.getLength = function () {\n        return queue.length;\n    };\n\n    this.isEmpty = function () {\n        return (queue.length == 0);\n    };\n\n    this.getContents = function () {\n        return queue;\n    };\n}\n\n/*\n * Adds a new node to the graph with name 'id'. \n */\nGraph.prototype.addNode = function (id) {\n    // Ensure the id provided is unique by seeing if it doesn't already exists in the idList.\n    for (let i = 0; i < this.idList.length; i++) {\n        if (this.idList[i] == id) {\n            console.log(\"A node with id\", id, \"already exists!\");\n            return;\n        }\n        ;\n    }\n\n    // Initialize new row with -inf's based on len of idList.\n    var newRow = [];\n    for (let i = 0; i < this.idList.length; i++) {\n        newRow[i] = -Infinity;\n    }\n\n    // Add the newly made row to our graph's adjMatrix.\n    this.adjMatrix.push(newRow);\n\n    // Add the id provided to our graph's idList\n    this.idList.push(id);\n\n    // Add new column to each row in our adjMatrix. Do this by appending -Infinity to each row.\n    for (let i = 0; i < this.idList.length; i++) {\n        this.adjMatrix[i].push(-Infinity);\n    }\n};\n\n\nGraph.prototype.deleteNode = function (id) {\n    var found = false;\n    var index;\n\n    //confirm node exists\n    for (let i = 0; i < this.idList.length; i++) {\n        if (this.idList[i] == id) {\n            found = true;\n            index = i;\n            break;\n        }\n        ;\n    }\n    ;\n\n    if (found == false) {\n        console.log(\"The node with id\", id, \"wasn't found.\");\n        return;\n    }\n    ;\n\n    //if found, find its index in the idList, k\n    for (let i = 0; i < this.adjMatrix.length; i++) {\n        if (this.idList[i] == id) {\n            index = i;\n            break;\n        }\n    }\n    ;\n\n    //splice out the [index]th element in idList\n    this.idList.splice(index, 1);\n\n    //splice out the [index]th row in adjMatrix\n    this.adjMatrix.splice(index, 1);\n\n    //splice out [index]th element from all other arrays\n    for (let i = 0; i < this.adjMatrix.length; i++) {\n        this.adjMatrix[i].splice(index, 1);\n    }\n    ;\n};\n\nGraph.prototype.addEdge = function (id1, id2, weight) {\n//NOTE: id1 is the 'from' node and id2 is the 'to' node\n//confirm if id1 and id2 are found in idList, confirming nodes are in graph\n//also find index of id1, i, and id2, j, in idList\n    let found1 = false;\n    let found2 = false;\n    var index1, index2;\n    for (let i = 0; i < this.idList.length; i++) {\n        if (this.idList[i] == id1 || this.idList[i] == id2) {\n            if (this.idList[i] == id1) {\n                found1 = true;\n                index1 = i;\n            }\n            ;\n            if (this.idList[i] == id2) {\n                found2 = true;\n                index2 = i;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n\n    if ((found1 && found2) != true) {\n        console.log(\"One of the nodes you provided aren't in the graph, so the edge can't be made.\");\n        return;\n    }\n    ;\n    this.adjMatrix[index1][index2] = weight;\n};\n\nGraph.prototype.updateEdge = function (id1, id2, newWeight) {\n    //NOTE : this method is the same as addEdge. Only added it for readability\n    this.addEdge(id1, id2, newWeight);\n};\n\nGraph.prototype.deleteEdge = function (id1, id2) {\n//NOTE: id1 is the 'from' node and id2 is the 'to' node\n//confirm if id1 and id2 are found in idList, confirming nodes are in graph\n//also find index of id1, i, and id2, j, in idList\n    let found1 = false;\n    let found2 = false;\n    var index1, index2;\n    for (let i = 0; i < this.idList.length; i++) {\n        if (this.idList[i] === id1 || this.idList[i] === id2) {\n            if (this.idList[i] === id1) {\n                found1 = true;\n                index1 = i;\n            }\n            if (this.idList[i] === id2) {\n                found2 = true;\n                index2 = i;\n            }\n        }\n        ;\n    }\n    ;\n\n    if ((found1 && found2) !== true) {\n        console.log(\"One of the nodes you provided aren't in the graph, so the edge can't be made.\");\n        return;\n    }\n    ;\n    this.adjMatrix[index1][index2] = -Infinity;\n};\n\nGraph.prototype.print = function () {\n    console.log(\"FROM\\\\TO\", this.idList);\n    for (let i = 0; i < this.adjMatrix.length; i++) {\n        console.log(\"'\" + this.idList[i] + \"'\", this.adjMatrix[i], \"\\n\");\n    }\n    ;\n    console.log(\"\\n\");\n};\n\n//getedges() : returns a list of edges in the format (from, to)\n\nGraph.prototype.getIdIndex = function (id) {\n    for (let i = 0; i < this.idList.length; i++) {\n        if (id == this.idList[i]) {\n            return i;\n        }\n        ;\n    }\n    ;\n    console.log(\"node with id\", id, \"doesn't exist in this graph.\");\n    return undefined;\n};\n\nGraph.prototype.getNeighbours = function (id) {\n    //description : returns all nodes reachable from the provided node\n    //find index of id in idList\n    var found = false;\n    var index;\n\n    //confirm node exists\n    for (let i = 0; i < this.idList.length; i++) {\n        if (this.idList[i] == id) {\n            found = true;\n            index = i;\n            break;\n        }\n        ;\n    }\n    ;\n\n\n    //if it doesn't exist, tell 'em\n    if (found == false) {\n        console.log(\"The node with id\", id, \"wasn't found.\");\n        return;\n    }\n    ;\n\n    //make array of neighbours\n    let neighbours = [];\n    for (let i = 0; i < this.adjMatrix[index].length; i++) {\n        if (this.adjMatrix[index][i] !== -Infinity && this.adjMatrix[index][i] !== 0) {  //if edge cap is 0, it can't carry flow, so it might as well not exist...\n            neighbours.push(this.idList[i]);\n        }\n        ;\n    }\n    ;\n    return neighbours;\n};\n\n//Breadth First Search-----------------------------------------------------------------------------\nfunction BFS(G, src, destination) {\n\n    let pred = {};\n    let dist = {};\n    let visited = [src];\n    let Q = new Queue();\n\n    for (let q = 0; q < G.idList.length; q++) {\n        let cur = G.idList[q];\n        pred[cur] = undefined;\n        dist[cur] = Infinity;\n    }\n\n    Q.enqueue(src);\n    dist[src] = 0;\n\n    while (Q.isEmpty() === false) {\n        var current = Q.dequeue();\n\n        if (G.getNeighbours(current) === undefined) {\n            continue;\n        }\n        ;\n\n        var neighbours = G.getNeighbours(current);\n        for (let i = 0; i < neighbours.length; i++) {\n            if (!visited.includes(neighbours[i])) {\n                pred[neighbours[i]] = current;\n                dist[neighbours[i]] = dist[current] + 1;\n\n                if (neighbours[i] == destination) {\n                    return {\n                        \"path\": getPath(pred, src, destination),\n                        \"dist\": dist[destination],\n                        \"visited\": visited\n                    };\n                }\n                ;\n                //make sure we haven't visited the node already\n\n                visited.push(neighbours[i]);\n                Q.enqueue(neighbours[i]);\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    return {\n        \"path\": [],\n        \"dist\": 0,\n        \"visited\": visited\n    };\n};\n\nfunction getPath(pred, src, dest) {\n    var current = dest;\n    let path = [];\n    while (current != undefined) {\n        path.unshift(current);\n        current = pred[current];\n    }\n    ;\n    return path;\n};\n\n//Residual Graph-----------------------------------------------------------------------------------\n/*\n * The residual graph which is generated based on a given Graph object. Used in FordFukerson().\n * @constructor\n * @extends {Graph}\n */\nResidualGraph.prototype = new Graph();\n\nfunction ResidualGraph(G) {\n\n    this.adjMatrix = [];\n    this.idList = [];\n\n    this.init = function (G) {\n        //deep cloning the adjMatrix and idList\n        for (let i = 0; i < G.adjMatrix.length; i++) {\n            let row = [];\n            for (let j = 0; j < G.adjMatrix[i].length; j++) {\n                row.push(G.adjMatrix[i][j]);\n            }\n            ;\n            this.adjMatrix.push(row);\n            this.idList.push(G.idList[i]);\n        }\n        ;\n\n        //adding the residual edges\n        for (let i = 0; i < G.adjMatrix.length; i++) {\n            for (let j = 0; j < G.adjMatrix[i].length; j++) {\n                if (i != j && G.adjMatrix[i][j] != -Infinity) {\n                    this.adjMatrix[j][i] = 0;\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    };\n    this.init(G);  //run the init on creation of an instance!\n\n    this.minCapacity = function (path) {\n        var min = Infinity;\n        for (let i = 1; i < path.length; i++) {\n            let from = path[i - 1];\n            let to = path[i];\n            var fromIndex;\n            var toIndex;\n            for (let j = 0; j < this.idList.length; j++) {\n                if (this.idList[j] == from) {\n                    fromIndex = j;\n                }\n                ;\n                if (this.idList[j] == to) {\n                    toIndex = j;\n                }\n                ;\n            }\n            ;\n            let value = this.adjMatrix[fromIndex][toIndex];\n            if (value < min) {\n                min = value;\n            }\n            ;\n        }\n        ;\n        return min;\n    };\n\n    this.adjustEdgesInPath = function (path, val) {\n        //adds val to each edge on path\n\n        //iterate through the path\n        for (let j = 1; j < path.length; j++) {\n            let from = this.getIdIndex(path[j - 1]);\n            let to = this.getIdIndex(path[j]);\n\n            if (from == undefined || to == undefined) {\n                console.log('something went wrong...');\n                return;\n            }\n            ;\n\n            let currentVal = this.adjMatrix[from][to];\n            this.adjMatrix[from][to] -= val;\n            this.adjMatrix[to][from] += val;\n        }\n        ;\n    };\n};\n\n//Ford-Fulkerson-----------------------------------------------------------------------------------\nfunction FordFulkerson(G, src, sink) {\n\n    var RS = new ResidualGraph(G);\n    let res;\n    while (true) {\n        res = BFS(RS, src, sink);\n        let path = res['path'];\n        if (path.length == 0) {\n            break;\n        }\n        ;\n\n        //find min\n        var min = RS.minCapacity(path);\n        RS.adjustEdgesInPath(path, min);\n\n    }\n    ;\n\n    let S = res['visited'];\n    //visited now contains all nodes in the S part of the S-T cut. Find all out-going from them.\n    let cut = new Set();\n    let flow = 0;\n    for (let k = 0; k < S.length; k++) {\n        var s = G.getNeighbours(S[k]);\n        let x = G.getIdIndex(S[k]);\n        for (let l = 0; l < s.length; l++) {\n            if (!S.includes(s[l])) {\n                cut.add([S[k], s[l]]);\n                flow += G.adjMatrix[G.getIdIndex(S[k])][G.getIdIndex(s[l])];\n            }\n            ;\n        }\n        ;\n    }\n    ;\n\n    console.log(\"MAX FLOW:\", flow);\n    console.log(\"MIN CUT\", cut);\n    return { flow, cut }\n};\n\nexport const calculateMaxFlow = (startVertex, finishVertex, vertices) => {\n    const graph = new Graph();\n    const nodeNames = getNodeNames(startVertex, finishVertex, vertices);\n\n    nodeNames.forEach(node => {\n        graph.addNode(node);\n    });\n    vertices.forEach(vertex => {\n        graph.addEdge(vertex.start, vertex.finish, +vertex.weight);\n    })\n\n    return FordFulkerson(graph, startVertex, finishVertex);\n}\n\nexport const getNodeNames = (startVertex, finishVertex, vertices) => {\n    const nodeStartNames = vertices.map(vertex => vertex.start);\n    const nodeFinishNames = vertices.map(vertex => vertex.finish);\n    return new Set([startVertex, finishVertex, ...nodeStartNames, ...nodeFinishNames])\n}\n","import React, { useState } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormControl from '@material-ui/core/FormControl';\nimport AddCircleIcon from '@material-ui/icons/AddCircle';\nimport RemoveCircleOutlineIcon from '@material-ui/icons/RemoveCircleOutline';\nimport { InputLabel, Input, IconButton, Button } from '@material-ui/core';\nimport calculatePath from '../helpers/calculatePath';\nimport Graph from './Graph'\nimport { getNodeNames } from \"../helpers/fordFulkerson\";\n\nconst useStyles = makeStyles((theme) => ({\n    formControl: {\n        minWidth: 120,\n        marginRight: '1rem'\n    },\n}));\n\nconst filterVertices = (vertices) => vertices.filter(vertex => vertex && vertex.weight && vertex.finish && vertex.start)\n\nexport default () => {\n    const classes = useStyles();\n    const emptyVertex = {\n        start: null,\n        finish: null,\n        weight: null,\n    }\n    const [startVertex, setStartVertex] = useState(null);\n    const [finishVertex, setFinishVertex] = useState(null);\n    const [vertices, setVertices] = useState([emptyVertex]);\n    const [distance, setDistance] = useState(null);\n    const [path, setPath] = useState([]);\n\n    const resetResult = () => {\n        setDistance(null);\n        setPath([]);\n    }\n\n    const addNewVertex = () => {\n        resetResult();\n        setVertices([\n            ...vertices,\n            emptyVertex\n        ])\n    }\n\n    const getVertexName = (name) => {\n        if (startVertex === name) {\n            return 'start';\n        }\n        if (finishVertex === name) {\n            return 'finish';\n        }\n        return name;\n    }\n\n    const updateVertexStart = (index, event) => {\n        resetResult();\n        const newVertices = [...vertices];\n        newVertices[index].start = event.target.value;\n        setVertices(newVertices);\n    }\n\n    const updateVertexFinish = (index, event) => {\n        resetResult();\n        const newVertices = [...vertices];\n        newVertices[index].finish = event.target.value;\n        setVertices(newVertices);\n    }\n\n    const updateVertexWeight = (index, event) => {\n        resetResult();\n        const newVertices = [...vertices];\n        newVertices[index].weight = event.target.value;\n        setVertices(newVertices);\n    }\n\n    const removeVertex = (index) => {\n        resetResult();\n        const newVertices = vertices.map((vertex, key) => key !== index ? vertex : null);\n        setVertices(newVertices);\n    }\n\n    const handleCalculateClick = () => {\n        const filteredVertices = filterVertices(vertices);\n        let result = {\n            [getVertexName(startVertex)]: {},\n            [getVertexName(finishVertex)]: {}\n        };\n\n        filteredVertices.forEach(vertex => {\n            const name = getVertexName(vertex.start);\n            const finishName = getVertexName(vertex.finish);\n            if (!result[name]) {\n                result[name] = {}\n            }\n            result[name][finishName] = +vertex.weight;\n        })\n\n        const calculatedPath = calculatePath(result);\n\n        setDistance(calculatedPath.distance);\n        setPath(calculatedPath.path);\n    }\n\n    const handleStartVertexChange = (event) => {\n        resetResult();\n        setPath([]);\n        setStartVertex(event.target.value);\n    }\n\n    const handleFinishVertexChange = event => {\n        resetResult();\n        setPath([]);\n        setFinishVertex(event.target.value);\n    }\n    const hasRequiredVertices = startVertex && finishVertex;\n    const disableCalculationButton = !hasRequiredVertices || filterVertices(vertices).length < 1;\n    const formattedPath = path.map(item => item === 'start' ? startVertex : item === 'finish' ? finishVertex : item)\n\n    return (\n        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column'}}>\n            <div style={{ width: '60%', alignItems: 'flex-start', display: 'flex', flexDirection: 'column' }}>\n                <div style={{ marginBottom: '2rem' }}>\n                    <FormControl className={classes.formControl}>\n                        <InputLabel htmlFor=\"pointName\">Початкова точка</InputLabel>\n                        <Input aria-describedby=\"my-helper-text\" onChange={handleStartVertexChange} />\n                    </FormControl>\n                    <FormControl className={classes.formControl}>\n                        <InputLabel htmlFor=\"pointName\">Кінцева точка</InputLabel>\n                        <Input aria-describedby=\"my-helper-text\" onChange={handleFinishVertexChange}/>\n                    </FormControl>\n                </div>\n                {vertices.map((vertex, index) => vertex && (\n                    <div key={`${index}`} style={{ marginBottom: '1rem' }}>\n                        <FormControl className={classes.formControl} disabled={!hasRequiredVertices}>\n                            <InputLabel>Вхідна вершина</InputLabel>\n                            <Input aria-describedby=\"my-helper-text\" onChange={event => updateVertexStart(index, event)} />\n                        </FormControl>\n                        <FormControl className={classes.formControl} disabled={!hasRequiredVertices}>\n                            <InputLabel>Вихідна вершина</InputLabel>\n                            <Input aria-describedby=\"my-helper-text\" onChange={event => updateVertexFinish(index, event)} />\n                        </FormControl>\n                        <FormControl className={classes.formControl} disabled={!hasRequiredVertices}>\n                            <InputLabel>Вага</InputLabel>\n                            <Input aria-describedby=\"my-helper-text\" onChange={event => updateVertexWeight(index, event)} />\n                        </FormControl>\n                        {vertices.length - 1 === index ? (\n                            <IconButton size=\"medium\" onClick={addNewVertex} disabled={!vertex.start || !vertex.finish || !vertex.weight}>\n                                <AddCircleIcon fontSize=\"inherit\" />\n                            </IconButton>\n                        ) : (\n                            <IconButton size=\"medium\" onClick={() => removeVertex(index)}>\n                                <RemoveCircleOutlineIcon fontSize=\"inherit\" />\n                            </IconButton>\n                        )}\n                    </div>\n                ))}\n                <Button\n                    variant=\"contained\"\n                    color=\"primary\"\n                    disabled={disableCalculationButton}\n                    onClick={handleCalculateClick}\n                >\n                    Розрахувати\n                </Button>\n                <div style={{ marginTop: '2rem' }}>\n                    {path.length > 0 && (\n                       <>\n                           <InputLabel>Найкоротший шлях - {distance} ({formattedPath.join(' - ')})</InputLabel>\n                       </>\n                    )}\n                </div>\n            </div>\n            {path.length > 0 && (\n                <Graph\n                    nodes={getNodeNames(startVertex, finishVertex, filterVertices(vertices))}\n                    vertices={filterVertices(vertices)}\n                />\n            )}\n        </div>\n    )\n}\n","import React, { useState } from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport FormControl from '@material-ui/core/FormControl';\nimport AddCircleIcon from '@material-ui/icons/AddCircle';\nimport RemoveCircleOutlineIcon from '@material-ui/icons/RemoveCircleOutline';\nimport { InputLabel, Input, IconButton, Button } from '@material-ui/core';\nimport { calculateMaxFlow, getNodeNames } from '../helpers/fordFulkerson';\nimport Graph from \"./Graph\";\n\nconst useStyles = makeStyles((theme) => ({\n    formControl: {\n        minWidth: 120,\n        marginRight: '1rem'\n    },\n}));\n\nconst filterVertices = (vertices) => vertices.filter(vertex => vertex && vertex.weight && vertex.finish && vertex.start)\n\nexport default () => {\n    const classes = useStyles();\n    const emptyVertex = {\n        start: null,\n        finish: null,\n        weight: null,\n    }\n    const [startVertex, setStartVertex] = useState(null);\n    const [finishVertex, setFinishVertex] = useState(null);\n    const [vertices, setVertices] = useState([emptyVertex]);\n    const [maxFlow, setMaxFlow] = useState(null);\n    const [minCut, setMinCut] = useState([]);\n\n    const addNewVertex = () => {\n        resetResult();\n        setVertices([\n            ...vertices,\n            emptyVertex\n        ])\n    }\n\n    const resetResult = () => {\n        setMinCut([]);\n        setMaxFlow(null);\n    }\n\n    const updateVertexStart = (index, event) => {\n        resetResult();\n        const newVertices = [...vertices];\n        newVertices[index].start = event.target.value;\n        setVertices(newVertices);\n    }\n\n    const updateVertexFinish = (index, event) => {\n        resetResult();\n        const newVertices = [...vertices];\n        newVertices[index].finish = event.target.value;\n        setVertices(newVertices);\n    }\n\n    const updateVertexWeight = (index, event) => {\n        resetResult();\n        const newVertices = [...vertices];\n        newVertices[index].weight = event.target.value;\n        setVertices(newVertices);\n    }\n\n    const removeVertex = (index) => {\n        resetResult();\n        const newVertices = vertices.map((vertex, key) => key !== index ? vertex : null);\n        setVertices(newVertices);\n    }\n\n    const handleCalculateClick = () => {\n        const filteredVertices = filterVertices(vertices);\n        const maxFlow = calculateMaxFlow(startVertex, finishVertex, filteredVertices)\n        setMaxFlow(maxFlow.flow)\n        setMinCut(Array.from(maxFlow.cut))\n    }\n\n    const handleStartVertexChange = (event) => {\n        resetResult();\n        setMaxFlow(null);\n        setStartVertex(event.target.value);\n    }\n\n    const handleFinishVertexChange = event => {\n        resetResult();\n        setMaxFlow(null);\n        setFinishVertex(event.target.value);\n    }\n    const hasRequiredVertices = startVertex && finishVertex;\n    const disableCalculationButton = !hasRequiredVertices || filterVertices(vertices).length < 1;\n\n    return (\n        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column'}}>\n            <div style={{ width: '60%', alignItems: 'flex-start', display: 'flex', flexDirection: 'column' }}>\n                <div style={{ marginBottom: '2rem' }}>\n                    <FormControl className={classes.formControl}>\n                        <InputLabel htmlFor=\"pointName\">Початкова точка</InputLabel>\n                        <Input aria-describedby=\"my-helper-text\" onChange={handleStartVertexChange} />\n                    </FormControl>\n                    <FormControl className={classes.formControl}>\n                        <InputLabel htmlFor=\"pointName\">Кінцева точка</InputLabel>\n                        <Input aria-describedby=\"my-helper-text\" onChange={handleFinishVertexChange}/>\n                    </FormControl>\n                </div>\n                {vertices.map((vertex, index) => vertex && (\n                    <div key={`${index}`} style={{ marginBottom: '1rem' }}>\n                        <FormControl className={classes.formControl} disabled={!hasRequiredVertices}>\n                            <InputLabel>Вхідна вершина</InputLabel>\n                            <Input aria-describedby=\"my-helper-text\" onChange={event => updateVertexStart(index, event)} />\n                        </FormControl>\n                        <FormControl className={classes.formControl} disabled={!hasRequiredVertices}>\n                            <InputLabel>Вихідна вершина</InputLabel>\n                            <Input aria-describedby=\"my-helper-text\" onChange={event => updateVertexFinish(index, event)} />\n                        </FormControl>\n                        <FormControl className={classes.formControl} disabled={!hasRequiredVertices}>\n                            <InputLabel>Вага</InputLabel>\n                            <Input aria-describedby=\"my-helper-text\" onChange={event => updateVertexWeight(index, event)} />\n                        </FormControl>\n                        {vertices.length - 1 === index ? (\n                            <IconButton size=\"medium\" onClick={addNewVertex} disabled={!vertex.start || !vertex.finish || !vertex.weight}>\n                                <AddCircleIcon fontSize=\"inherit\" />\n                            </IconButton>\n                        ) : (\n                            <IconButton size=\"medium\" onClick={() => removeVertex(index)}>\n                                <RemoveCircleOutlineIcon fontSize=\"inherit\" />\n                            </IconButton>\n                        )}\n                    </div>\n                ))}\n                <Button\n                    variant=\"contained\"\n                    color=\"primary\"\n                    disabled={disableCalculationButton}\n                    onClick={handleCalculateClick}\n                >\n                    Розрахувати\n                </Button>\n                <div style={{ marginTop: '2rem' }}>\n                    {maxFlow && (\n                       <>\n                           <InputLabel>Максимальний потік - {maxFlow}</InputLabel>\n                           <InputLabel>Мінімальний переріз - ({minCut.map(item => item.join(', ')).join(')(')})</InputLabel>\n                       </>\n                    )}\n                </div>\n            </div>\n            {maxFlow && (\n                <Graph\n                    nodes={getNodeNames(startVertex, finishVertex, filterVertices(vertices))}\n                    vertices={filterVertices(vertices)}\n                />\n            )}\n        </div>\n    )\n}\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Tabs from '@material-ui/core/Tabs';\nimport Tab from '@material-ui/core/Tab';\nimport Typography from '@material-ui/core/Typography';\nimport Box from '@material-ui/core/Box';\nimport MintiForm from './MintiForm';\nimport FulkersonForm from './FulkersonForm';\n\nfunction TabPanel(props) {\n    const { children, value, index, ...other } = props;\n\n    return (\n        <div\n            role=\"tabpanel\"\n            hidden={value !== index}\n            id={`simple-tabpanel-${index}`}\n            aria-labelledby={`simple-tab-${index}`}\n            {...other}\n        >\n            {value === index && (\n                <Box p={3}>\n                    <Typography>{children}</Typography>\n                </Box>\n            )}\n        </div>\n    );\n}\n\nfunction a11yProps(index) {\n    return {\n        id: `simple-tab-${index}`,\n        'aria-controls': `simple-tabpanel-${index}`,\n    };\n}\n\nconst useStyles = makeStyles((theme) => ({\n    root: {\n        flexGrow: 1,\n        backgroundColor: theme.palette.background.paper,\n    },\n}));\n\nexport default function SimpleTabs() {\n    const classes = useStyles();\n    const [value, setValue] = React.useState(0);\n\n    const handleChange = (event, newValue) => {\n        setValue(newValue);\n    };\n\n    return (\n        <div className={classes.root}>\n            <AppBar position=\"static\">\n                <Tabs value={value} onChange={handleChange} aria-label=\"simple tabs example\">\n                    <Tab label=\"Метод Мінті\" {...a11yProps(0)} />\n                    <Tab label=\"Метод Форда-Фалкерсона\" {...a11yProps(1)} />\n                </Tabs>\n            </AppBar>\n            <TabPanel value={value} index={0}>\n                <MintiForm />\n            </TabPanel>\n            <TabPanel value={value} index={1}>\n                <FulkersonForm />\n            </TabPanel>\n        </div>\n    );\n}\n","import Tabs from './components/Tabs'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Tabs />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}